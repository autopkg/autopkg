#!/usr/local/autopkg/python
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import imp
import os
import plistlib
import sys
import unittest
from unittest.mock import Mock, mock_open, patch

# Add the Code directory to the Python path to resolve autopkg dependencies
sys.path.insert(0, os.path.join(os.path.dirname(__file__), ".."))

autopkg = imp.load_source(
    "autopkg", os.path.join(os.path.dirname(__file__), "..", "autopkg")
)


class TestAutoPkgRun(unittest.TestCase):
    """Test cases for recipe run related functions of AutoPkg."""

    def test_run_recipes_no_arguments(self):
        """Test run_recipes with no recipe arguments."""
        argv = ["autopkg", "run"]

        with patch.object(autopkg, "log_err") as mock_log_err:
            result = autopkg.run_recipes(argv)
            self.assertEqual(result, -1)
            # Should log an error about usage
            mock_log_err.assert_called()

    def test_run_recipes_install_verb_transforms_name(self):
        """Test run_recipes with install verb transforms recipe names."""
        # Test the argument processing logic that transforms names

        # Mock the core functions but avoid mocking open to prevent gettext issues
        mock_file = mock_open()
        mock_file.return_value.write = Mock()

        argv = ["autopkg", "install", "TestApp"]

        with patch.object(autopkg, "get_override_dirs", return_value=[]), patch.object(
            autopkg, "get_search_dirs", return_value=[]
        ), patch.object(autopkg, "get_pref", return_value="/tmp/cache"), patch.object(
            autopkg, "load_recipe", return_value=None
        ) as mock_load_recipe, patch(
            "os.path.exists", return_value=True
        ), patch(
            "os.makedirs"
        ), patch.object(
            autopkg, "plist_serializer", return_value={}
        ), patch.object(
            autopkg.plistlib, "dump"
        ), patch.object(
            autopkg, "log_err"
        ):

            # We expect this to fail when it tries to open the results file
            # but we should capture the load_recipe call first
            try:
                autopkg.run_recipes(argv)
            except OSError:
                # Expected failure when trying to write to results file
                pass

            # Should have called load_recipe with .install extension
            mock_load_recipe.assert_called()
            called_args = mock_load_recipe.call_args[0]
            self.assertEqual(called_args[0], "TestApp.install")

    def test_run_recipes_install_verb_rejects_non_install_extension(self):
        """Test run_recipes with install verb rejects non-.install extensions."""
        argv = ["autopkg", "install", "TestApp.recipe"]

        with patch.object(autopkg, "get_override_dirs", return_value=[]), patch.object(
            autopkg, "get_search_dirs", return_value=[]
        ), patch.object(autopkg, "get_pref", return_value="/tmp/cache"), patch.object(
            autopkg, "load_recipe", return_value=None
        ), patch(
            "os.path.exists", return_value=True
        ), patch(
            "os.makedirs"
        ), patch.object(
            autopkg, "plist_serializer", return_value={}
        ), patch.object(
            autopkg.plistlib, "dump"
        ), patch.object(
            autopkg, "log_err"
        ) as mock_log_err:

            try:
                autopkg.run_recipes(argv)
            except OSError:
                # Expected failure when trying to write to results file
                pass

            # Should log error about non-install recipe
            mock_log_err.assert_called()
            error_messages = [call.args[0] for call in mock_log_err.call_args_list]
            install_error = any(
                "Can't install with a non-install recipe" in msg
                for msg in error_messages
            )
            self.assertTrue(install_error)

    def test_run_recipes_pkg_with_multiple_recipes_error(self):
        """Test run_recipes with --pkg option and multiple recipes (should error)."""
        argv = [
            "autopkg",
            "run",
            "--pkg",
            "/path/to/package.pkg",
            "TestApp1.recipe",
            "TestApp2.recipe",
        ]

        with patch.object(autopkg, "get_override_dirs", return_value=[]), patch.object(
            autopkg, "get_search_dirs", return_value=[]
        ), patch.object(autopkg, "log_err"):

            result = autopkg.run_recipes(argv)
            self.assertEqual(result, -1)

    def test_run_recipes_invalid_key_value_format(self):
        """Test run_recipes with invalid key=value format."""
        argv = ["autopkg", "run", "-k", "INVALID_FORMAT", "TestApp.recipe"]

        with patch.object(autopkg, "get_override_dirs", return_value=[]), patch.object(
            autopkg, "get_search_dirs", return_value=[]
        ), patch.object(autopkg, "log_err"):

            result = autopkg.run_recipes(argv)
            self.assertEqual(result, 1)

    def test_run_recipes_recipe_not_found(self):
        """Test run_recipes when recipe is not found."""
        argv = ["autopkg", "run", "NonExistentRecipe.recipe"]

        with patch.object(autopkg, "get_override_dirs", return_value=[]), patch.object(
            autopkg, "get_search_dirs", return_value=[]
        ), patch.object(autopkg, "get_pref", return_value="/tmp/cache"), patch.object(
            autopkg, "load_recipe", return_value=None
        ), patch(
            "os.path.exists", return_value=True
        ), patch(
            "os.makedirs"
        ), patch.object(
            autopkg, "plist_serializer", return_value={}
        ), patch.object(
            autopkg.plistlib, "dump"
        ), patch.object(
            autopkg, "log_err"
        ):

            try:
                result = autopkg.run_recipes(argv)
                # Should return error code due to recipe not found
                self.assertEqual(result, 70)  # RECIPE_FAILED_CODE
            except OSError:
                # If it fails due to file operations, that's also acceptable
                # since we're mainly testing the recipe not found logic
                pass

    def test_parse_recipe_list_plist_format(self):
        """Test parse_recipe_list with plist format."""
        import tempfile

        recipe_list_data = {
            "recipes": ["TestApp1.recipe", "TestApp2.recipe"],
            "preprocessors": ["PreProcessor1"],
            "postprocessors": ["PostProcessor1"],
            "CUSTOM_VAR": "custom_value",
        }

        with tempfile.NamedTemporaryFile(mode="wb", suffix=".plist", delete=False) as f:
            plistlib.dump(recipe_list_data, f)
            temp_file = f.name

        try:
            result = autopkg.parse_recipe_list(temp_file)
            self.assertEqual(result["recipes"], ["TestApp1.recipe", "TestApp2.recipe"])
            self.assertEqual(result["preprocessors"], ["PreProcessor1"])
            self.assertEqual(result["postprocessors"], ["PostProcessor1"])
            self.assertEqual(result["CUSTOM_VAR"], "custom_value")
        finally:
            os.unlink(temp_file)

    def test_parse_recipe_list_text_format(self):
        """Test parse_recipe_list with plain text format."""
        import tempfile

        recipe_list_text = """# This is a comment
TestApp1.recipe
TestApp2.recipe

# Another comment
TestApp3.recipe
"""

        with tempfile.NamedTemporaryFile(mode="w", suffix=".txt", delete=False) as f:
            f.write(recipe_list_text)
            temp_file = f.name

        try:
            result = autopkg.parse_recipe_list(temp_file)
            expected_recipes = ["TestApp1.recipe", "TestApp2.recipe", "TestApp3.recipe"]
            self.assertEqual(result["recipes"], expected_recipes)
        finally:
            os.unlink(temp_file)

    def test_parse_recipe_list_empty_lines_and_comments(self):
        """Test parse_recipe_list ignores empty lines and comments."""
        import tempfile

        recipe_list_text = """
# Comment line 1
TestApp1.recipe
# Comment line 2

TestApp2.recipe
# Final comment
"""

        with tempfile.NamedTemporaryFile(mode="w", suffix=".txt", delete=False) as f:
            f.write(recipe_list_text)
            temp_file = f.name

        try:
            result = autopkg.parse_recipe_list(temp_file)
            # Should only include non-comment, non-empty lines
            expected_recipes = ["TestApp1.recipe", "TestApp2.recipe"]
            self.assertEqual(result["recipes"], expected_recipes)
        finally:
            os.unlink(temp_file)

    def test_run_recipes_failure_includes_recipe_id(self):
        """Test that recipe failures include recipe_id in the failures array when recipe has an Identifier."""
        import tempfile

        argv = [
            "autopkg",
            "run",
            "--report-plist",
            "/tmp/test_report.plist",
            "TestApp.recipe",
        ]
        test_recipe_id = "com.test.TestApp"

        # Mock recipe with an identifier
        mock_recipe = {
            "RECIPE_PATH": "/path/to/TestApp.recipe",
            "Identifier": test_recipe_id,
            "Input": {},
            "Process": [],
        }

        # Mock AutoPackager that will raise an exception during processing
        mock_autopackager = Mock()
        mock_autopackager.results = []
        mock_autopackager.env = {"RECIPE_CACHE_DIR": "/tmp"}
        mock_autopackager.process.side_effect = autopkg.AutoPackagerError("Test error")

        # Create a temporary directory for cache
        with tempfile.TemporaryDirectory() as temp_cache_dir:
            with patch.object(
                autopkg, "get_override_dirs", return_value=[]
            ), patch.object(autopkg, "get_search_dirs", return_value=[]), patch.object(
                autopkg, "get_pref", return_value=temp_cache_dir
            ), patch.object(
                autopkg, "load_recipe", return_value=mock_recipe
            ), patch.object(
                autopkg, "AutoPackager", return_value=mock_autopackager
            ), patch.object(
                autopkg, "verify_parent_trust"
            ), patch(
                "os.path.exists", return_value=True
            ), patch(
                "os.makedirs"
            ), patch.object(
                autopkg, "plist_serializer", return_value={}
            ), patch.object(
                autopkg.plistlib, "dump"
            ), patch.object(
                autopkg, "log"
            ), patch.object(
                autopkg, "log_err"
            ), patch.object(
                autopkg, "write_plist_exit_on_fail"
            ) as mock_write_plist:

                # Run the function
                result = autopkg.run_recipes(argv)

                # Should return failure code
                self.assertEqual(result, 70)  # autopkg.RECIPE_FAILED_CODE

                # Check that write_plist_exit_on_fail was called
                self.assertTrue(mock_write_plist.called)

                # Extract the report data that would be written to the plist
                call_args = mock_write_plist.call_args[0]
                report_data = call_args[0]  # First argument is the report dictionary

                # Verify failures array exists and contains our failure
                self.assertIn("failures", report_data)
                failures = report_data["failures"]
                self.assertEqual(len(failures), 1)

                # Verify the failure contains the recipe_id
                failure = failures[0]
                self.assertIn("recipe_id", failure)
                self.assertEqual(failure["recipe_id"], test_recipe_id)
                self.assertIn("recipe", failure)
                self.assertEqual(failure["recipe"], "TestApp.recipe")
                self.assertIn("message", failure)
                self.assertEqual(failure["message"], "Test error")
                self.assertIn("traceback", failure)
